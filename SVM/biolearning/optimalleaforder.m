function order = optimalleaforder(Z,Y,varargin)
%OPTIMALLEAFORDER optimal leaf ordering for hierarchical clustering.
%
%   OPTIMALLEAFORDER(Z,Y) returns the optimal leaf ordering for the
%   hierarchical binary cluster tree represented by Z. An optimal leaf 
%   ordering of a binary tree maximizes the similarity between adjacent
%   clusters (or leaves) by flipping tree branches and without dividing the
%   clusters. Z is an (M-1)-by-3 matrix, generated by the LINKAGE function,
%   where M is the number of leaves. The input Y is a distance matrix
%   such as is generated by PDIST.
%
%   OPTIMALLEAFORDER(...,'CRITERIA',C) selects the optimization criteria.
%   Options are:  
%      'adjacent' (default) - Minimizes the sum of distances between
%                             adjacent leaves.
%      'group'              - Minimizes the sum of distances between every
%                             leaf and all other leaves in the adjacent
%                             cluster. 
%
%   OPTIMALLEAFORDER(...,'TRANSFORMATION',T) optimal leaf ordering works
%   internally by maximizing similarities between leaves. T selects the
%   method to transform the distances in DIST into similarity values. 
%   Options are:
%      'linear' (default) - Similarity = max(all distances) - distance.
%      'quadratic'        - Similarity = (max(all distances)-distance)^2.
%      'inverse'          - Similarity = 1/distance.
%      function handle    - A transformation created using @. It should
%                           represent a monotonic decreasing function in
%                           the range of the distance values. It must allow
%                           a vector input and must return an output with
%                           the same size.
%
%   Examples:
%       X = rand(10,2);
%       Y = pdist(X,'cityblock');
%       Z = linkage(Y,'average');
%       order = optimalleaforder(Z,Y)
%
%       % CLUSTERGRAM has optimal leaf ordering built-in
%       n = 35;
%       X = gallery('circul',n)-n/2;
%       X = X(randperm(n),:);
%       figure; clustergram(X,'rowlabels',1:n,'optimalleaforder',false)
%       figure; clustergram(X,'rowlabels',1:n,'optimalleaforder',true)
%
%   See also CLUSTERGRAM, CLUSTERGRAMDEMO, DENDROGRAM, LINKAGE, PDIST.

%   Reference:
%   Bar-Joseph Z, Gifford DK, Jaakkola TS. Fast optimal leaf ordering for
%   hierarchical clustering. Bioinformatics. 2001;17 Suppl 1:S22-9. PMID:
%   11472989

% Copyright 2006-2008 The MathWorks, Inc.
% $Revision: 1.1.6.5 $   $Date: 2008/06/16 16:32:42 $

bioinfochecknargin(nargin,2,mfilename)

numLeaves = size(Z,1)+1;

% check the tree
if ~any(size(Z,2)==[2 3])
    error('Bioinfo:optimalleaforder:BadSizedTree','Z must have 2 or 3 columns.')
end
if sum(diff(sort(Z(1:2*(numLeaves-1))))~=1) || (min(Z(1:2*(numLeaves-1)))~=1)
    error('Bioinfo:optimalleaforder:IncompleteTree','Z is not compatible with output of the LINKAGE function.')
end
h = any(Z(:,[1 2])'>=repmat(numLeaves+1:2*numLeaves-1,2,1));
if any(h)
    error('Bioinfo:optimalleaforder:NonChronologicalTree',...
          ['Branch(es) in Z not in chronological order: [' num2str(find(h)) ']'])
end

if any(isnan(Y))
    error('Bioinfo:optimalleaforder:NaNsInData',...
          'The distance matrix Y contains one of more NaN. OPTIMALLEAFORDER does not support NaN values.');
end
    

% Turn the matrix into the squareform when needed and check size.
if isequal([min(size(Y)),(1+sqrt(1+8*max(size(Y))))/2],[1,numLeaves])
    Y = squareform(Y);
elseif ~isequal(size(Y),[numLeaves,numLeaves])
    error('Bioinfo:optimalleaforder:BadSizedDist',...
          'Size of DIST not compatible with the output of the PDIST function.');
end

% set defaults for optional PV input arguments
transFunction = @(d) max(d(:))-d;
%transFunction = @(d) 1./d;
groupCriteria = false;
% read in optional PV input arguments
nvarargin = numel(varargin);
if nvarargin
    if rem(nvarargin,2) == 1
        error('Bioinfo:optimalleaforder:IncorrectNumberOfArguments',...
            'Incorrect number of arguments to %s.',mfilename);
    end
    okargs = {'criteria','transformation'};
    for j=1:2:nvarargin-1
        pname = varargin{j};
        pval = varargin{j+1};
        k = find(strncmpi(pname,okargs,numel(pname)));
        if isempty(k)
            error('Bioinfo:optimalleaforder:UnknownParameterName',...
                'Unknown parameter name: %s.',pname);
        elseif length(k)>1
            error('Bioinfo:optimalleaforder:AmbiguousParameterName',...
                'Ambiguous parameter name: %s.',pname);
        else
            switch(k)
                case 1 % 'criteria'
                    criteriaOptions = {'adjacent','group'};
                    selcriteria = strmatch(lower(pval),criteriaOptions); 
                    if isempty(selcriteria)
                        error('Bioinfo:optimalleaforder:NotValidCriteria',...
                            'Not a valid criteria for minimizing distances between leaves.')
                    else
                        groupCriteria = selcriteria == 2;
                    end
                case 2 % 'transformation'
                    if isa(pval,'function_handle')
                        transFunction = pval;
                    else
                        transMethods = {'linear','inverse','quadratic'};
                        transMethod = strmatch(lower(pval),transMethods); 
                        if isempty(transMethod)
                            error('Bioinfo:optimalleaforder:NotValidTransformation',...
                                'Not a valid method to transform distances to similarities.')
                        else
                            switch transMethod
                                case 1 % 'linear'
                                    transFunction = @(d) max(d(:))-d;
                                case 2 % 'inverse'
                                    transFunction = @(d) 1./d;
                                case 3 % 'quadratic'
                                    transFunction = @(d) (max(d(:))-d).^2;
                            end
                        end
                    end
            end
        end
    end
end

% transform to similarities
mask = true(1,numLeaves*numLeaves);
mask(1:numLeaves+1:numLeaves*numLeaves)=false;
try
    Y(mask) = transFunction(Y(mask));
catch theException
    error('Bioinfo:optimalleaforder:TransformationFunctionError',...
          ['The transformation function ''%s'' generated the following ', ...
           'error:\n%s'], func2str(transFunction),theException.message);
end

% initialize the scoring and traceback matrices
scores = -inf(numLeaves);
tracebackMatrix = zeros(numLeaves,'uint32');

% main loop
for outer = 1:size(Z,1)
    % get the leaves of the node
    leftLeaves = getChildrenFromNode(Z(outer,1));
    rightLeaves = getChildrenFromNode(Z(outer,2));
    numLeft = numel(leftLeaves);
    numRight = numel(rightLeaves);
    dm = Y(rightLeaves,leftLeaves);
    if groupCriteria
       srdm=sum(dm,2); scdm=sum(dm,1); 
       dm = srdm(:,ones(numLeft,1))+scdm(ones(numRight,1),:);
    end
    if numLeft == 1
        if numRight == 1
            % If we are at a node that has just two leaves then there is
            % nothing to calculate and we only populate the traceback matrices.
            scores(leftLeaves,rightLeaves) = dm;
            scores(rightLeaves,leftLeaves) = dm;
            tracebackMatrix(rightLeaves,leftLeaves) = rightLeaves;
            tracebackMatrix(leftLeaves,rightLeaves) = leftLeaves;
        else
            % We are at a node that has one leaf on the left and a branch
            % on the right; use a vectorized approach to find a right-inner
            % leaf that leads to a maximum score for every possible
            % right-outer leaf:  
            [BEST,TR] = max(dm(:,ones(numRight,1))+scores(rightLeaves,rightLeaves));
            scores(leftLeaves,rightLeaves) = BEST;
            scores(rightLeaves,leftLeaves) = BEST;
            scores(rightLeaves,rightLeaves) = -inf;
            tracebackMatrix(rightLeaves,leftLeaves)  = rightLeaves(TR);
            tracebackMatrix(leftLeaves, rightLeaves) = leftLeaves;
        end
    elseif numRight == 1
        % We are at a node that has one leaf on the right and a branch on
        % the left; use a vectorized approach to find a left-inner leaf
        % that leads to a maximum score for every possible left-outer leaf: 
        [BEST,TL] = max(dm(ones(numLeft,1),:)'+scores(leftLeaves,leftLeaves));        
        scores(leftLeaves,rightLeaves) = BEST;
        scores(rightLeaves,leftLeaves) = BEST;
        scores(leftLeaves,leftLeaves) = -inf;
        tracebackMatrix(rightLeaves,leftLeaves)  = rightLeaves;
        tracebackMatrix(leftLeaves, rightLeaves) = leftLeaves(TL);
    else
        % We are at a node that joins two branches, each one with more than
        % one leave, sort the scores as we will loop over the highest
        % scores until we know that the next combination cannot be better
        % than the existing best (Bar-Joseph, et.al., 2001):
        [maxL,lPerm] = sort((scores(leftLeaves,leftLeaves)),1,'descend');
        [maxR,rPerm] = sort((scores(rightLeaves,rightLeaves)),1,'descend');
        dm_maxL = max(dm);
        dm_maxLR = max(dm_maxL);
        for left = 1:numLeft
            for right = 1:numRight
                best = -inf;
                tL = 0;
                tR = 0;
                % set threshold to end global search
                maxPosR = maxR(1,right) + dm_maxLR;
                for iiL = 1:numLeft-1
                    innerL = lPerm(iiL,left);
                    scoreL = maxL(iiL,left);
                    % Is there a chance we can improve ?
                    if scoreL + maxPosR <= best
                        break
                    end
                    % set threshold to end search for best right-inner
                    % leaf, Bar-Joseph et.al., used dm_maxLR, but
                    % dm_maxL(innerL) further improves the speed up
                    maxPosL = scoreL + dm_maxL(innerL);
                    for iiR = 1:numRight-1
                        innerR = rPerm(iiR,right);
                        scoreR = maxR(iiR,right);
                        % Is there a chance we can improve with this
                        % left-inner leaf ? 
                        if maxPosL + scoreR <= best
                            break
                        end
                        val = scoreL + scoreR + dm(innerR,innerL);
                        if val>best
                            best = val;
                            tL = leftLeaves(innerL);
                            tR = rightLeaves(innerR);
                        end
                    end % for iiR = 1:numRight-1
                end % for iiL = 1:numLeft-1
                % populate the traceback information
                scores(leftLeaves(left),rightLeaves(right)) = best;
                scores(rightLeaves(right),leftLeaves(left)) = best;
                tracebackMatrix(rightLeaves(right),leftLeaves(left)) = tR;
                tracebackMatrix(leftLeaves(left), rightLeaves(right)) = tL;
            end % for right = 1:numRight
        end % for left = 1:numLeft
        scores(leftLeaves,leftLeaves) = -inf;
        scores(rightLeaves,rightLeaves) = -inf;
    end % numLeft > 1  && numRight > 1
end % for outer = 1:size(Z,1)

% Follow the traceback matrix to create a predecessor list 
lq = zeros(numLeaves,1); % left queue
rq = zeros(numLeaves,1); % right queue
dl = zeros(numLeaves,1); % descendants list

% find the global best from the last join
[i,j] = find(scores(leftLeaves,rightLeaves)==max(max(scores(leftLeaves,rightLeaves))),1);
bestL = leftLeaves(i); bestR = rightLeaves(j);

i = 1; lq(1) = bestL;  rq(1) = bestR;         % initialize queue
while i>0 % until queue is empty
    left = lq(i); right = rq(i); i = i - 1;   % remove next from queue
    % find inner leaves in the traceback matrix
    lr = tracebackMatrix(left,right);
    rl = tracebackMatrix(right,left);
    if right~=rl
        i = i + 1; lq(i) = rl; rq(i) = right; % update queue
        dl([lr rl]) = [rl right];             % update descendants list
    end
    if left~=lr
        i = i + 1; lq(i) = left; rq(i) = lr;  % update queue
        dl([left lr]) = [lr rl];              % update descendants list
    end
end

% recover order from the predecessor list
order = zeros(1,numLeaves); 
order(1) = bestL;
for i = 1:numLeaves-1
    order(i+1) = dl(order(i));
end

% flip the tree ?
if sum(abs(order-(1:numLeaves)))>sum(abs(order-(numLeaves:-1:1)))
    order = fliplr(order);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Nested function  %%%%%%%%%%%%%%%%%%%%%%%%%%%%
    function kids = getChildrenFromNode(node)
        if node <= numLeaves % nothing to do if node is a leaf
            kids = node;
        else
            % run through the branches of the nodes.
            out = false(1,node);
            out(node) = true;
            for count = node:-1:numLeaves+1
                if out(count)
                    out(Z(count-numLeaves,[1 2])) = true;
                end
            end
            % find the leaves that are children
            kids = find(out(1:numLeaves));
        end
    end % of nested function
end % of main function

